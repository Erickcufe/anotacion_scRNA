---
title: "Anotacion tipos celulares"
format: 
  revealjs:
    logo: img/cdsb.png
    footer: "EBM 2023"
editor: visual
---

## Anotación de tipos celulares

**BIENVENIDOS**

Presenta: Erick Cuevas Fernández

![](img/xolo.png){.absolute bottom="0" right="0" width="300" height="300"}

![](img/bioconductor.png){.absolute bottom="0" left="0" width="300" height="100"}

![](img/nnb.png){.absolute bottom="0" left="400" width="300" height="100"}

![](img/rmb.png){.absolute top="400" left="400" width="300" height="100"}

![](img/avatar.png){.absolute top="400" left="0" width="100" height="100"}

![](img/ccg.png){.absolute top="400" left="200" width="80" height="80"}

## Anotación de clusters {.scrollable}

::: incremental
1.  **Identificación de tipos y Subtipos Celulares.**
2.  **Entender la función celular.**
3.  **Descubrimiento de nuevos tipos celulares.**
4.  **Base para análisis posteriores.**
:::

![](img/fruit.png){.r-stretch}

::: footer
Lisa Maria Steinheuer et al., 2021
:::

## Conjunto de datos a trabajar

[Tom Alsaigh et al. 2022](https://www.nature.com/articles/s42003-022-04056-7)

La mejor estrategia para anotar, es entender el problema.

![](img/h_sabio.jpg)

## Antes de seguir, tip para aprovechar lo mejor de dos mundos SingleCellExperiment y Seurat {.scrollable}

**De Seurat a SingleCellExperiment**

```{r, eval=FALSE, echo=TRUE}
library(SingleCellExperiment)

so # Seurat Object

sce <- as.SingleCellExperiment(so, assay = "RNA")
colData(sce) <- as.data.frame(colData(sce)) |>
  mutate_if(is.character, as.factor) |>
  DataFrame(row.names = colnames(sce))
```

**De SingleCellExperiment a Seurat**

```{r, eval=FALSE, echo=TRUE}
library(SeuratObject)

sce # SingleCellExperiment object

so <- CreateSeuratObject(
  counts = counts(sce),
  meta.data = data.frame(colData(sce)),
  project = "Nombre_del_proyecto")
```


## Notas de SeuratObject y SingleCellEXperiment Object

::: {.panel-tabset}

### SingleCellExperiment

El objeto **SCE** usa la estructura de SummarizedExperiment. Los *slots* extra que tiene son: 

1. **assays**
2. **colData**
3. **rowData** 
4. **reducedDims** 

### Seurat

El objeto **Seurat** se conforma de los siguientes *slots*: 

1. **@data**
2. **@meta.data**
3. **@assays**
4. **@reductions**

:::

## Importacion de datos {.scrollable}

::: {.r-fit-text}

Pasamos de SO a SCE

```{r, eval=FALSE, echo=TRUE}
library(Seurat)
library(dplyr)
library(SingleCellExperiment)


# Recuerda descargar primero el dataset del link
so <- readRDS("alsaigh_part2.rds")

# Lo convertimos a sce

sce <- as.SingleCellExperiment(so, assay = "RNA")
colData(sce) <- as.data.frame(colData(sce)) %>%
  mutate_if(is.character, as.factor) %>%
  DataFrame(row.names = colnames(sce))

# Definimos resolucion
cluster_cols <- grep("res.[0-9]", colnames(colData(sce)), value = TRUE)
sapply(colData(sce)[cluster_cols], nlevels)


```

:::

## Enfoque automático: a partir de un dataset de referencia {.scrollable}

**Dataset de referencia**

```{r, eval=FALSE, echo=TRUE}

# Para anotar
# cargar datos de referencia con anotaciones de Ensembl.
library(celldex)
ref.data <- HumanPrimaryCellAtlasData(ensembl=TRUE)

library(biomaRt)
library(SummarizedExperiment)

# Seleccione la base de datos Ensembl
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# Extraer los ID de Ensembl del objeto SummarizedExperiment
ensembl_ids <- rownames(ref.data)

# Obtener los símbolos genéticos correspondientes a los ID de Ensembl
annotations <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                     filters = "ensembl_gene_id", values = ensembl_ids, mart = ensembl)

# Fusionar anotaciones con rowData del objeto SummarizedExperiment
rowData(ref.data)$geneSymbol <- annotations$hgnc_symbol[match(ensembl_ids, annotations$ensembl_gene_id)]
rownames(ref.data) <- rowData(ref.data)$geneSymbol


```

## Usando SingleR {auto-animate="true"}

```r
library(SingleR)
library(scater)

pred <- SingleR(test = sce,
                ref = ref.data,
                labels = ref.data$label.main,
                assay.type.test=1)


```
## Usando SingleR {auto-animate="true" .scrollable}

```r
library(SingleR)
library(scater)

pred <- SingleR(test = sce, 
                ref = ref.data,
                labels = ref.data$label.main,
                assay.type.test=1,
                BPPARAM= BiocParallel::MulticoreParam(6)) # 6 CPUs.

table(pred$labels)


```
Parámetros Principales:

*    **test**: Una matriz de expresión donde las filas son genes y las columnas son células a anotar.
*    **ref**: Una lista de matrices de expresión que representan las bases de datos de referencia.
*    **labels**: Etiquetas para los tipos celulares en las bases de datos de referencia.
*    **de.method**: Método para calcular los genes diferencialmente expresados.
*    **BPPARAM**: Parámetros para la paralelización.


## Observar calidad de predicción {.scrollable}

::: {.panel-tabset}

### Output de la predicción

```{r, eval=FALSE, echo=TRUE}
colnames(pred)

table(pred$labels)

head(sort(table(pred$labels), decreasing=TRUE))

```



### Diagnóstico de anotación

```{r, eval=FALSE, echo=TRUE}

SingleR::plotScoreHeatmap(pred)


```

![](img/alsaigh_plotScoreHeatmap.jpeg)

### Sin podado de etiquetas {.scrollable}

```{r, eval=FALSE, echo=TRUE}
table(pred$labels)

sce$ProbLabels <- pred$labels

plotReducedDim(sce, "TSNE", colour_by="ProbLabels")

```

![](cluster_v1.png)

### Podado de etiquetas {.scrollable}

```{r, eval=FALSE, echo=TRUE}
summary(is.na(pred$pruned.labels))


# Grafico para ver las celulas eliminadas

# plotDeltaDistribution(pred.grun, ncol = 3)

to.remove <- is.na(pred$pruned.labels)
table(Label=pred$labels, Removed=to.remove)

to.remove <- pruneScores(pred, min.diff.med=0.2)
table(Label=pred$labels, Removed=to.remove)

# Modificamos nuestro sce
sce_dummy <- sce[,to.remove]
sce_dummy$new_labels <- pred$labels[to.remove]
table(sce_dummy$new_labels)

plotReducedDim(sce_dummy, "TSNE", colour_by="new_labels")

```

![](img/cluters_pruned.png)

:::


## Aproximación "artesanal" 

**¿Qué hacemos si nuestra anotación aún no es la "ideal"?**

![](img/arte.jpeg)

## Podemos primero eliminar {.scrollable}

Ver que tipos celulares son "innecesarios"

```{r, eval=FALSE, echo=TRUE}
library(Seurat)

# Recuerda que el archivo original era un "so"

so@meta.data$Proplabels <- sce$ProbLabels

# Le transferimos las etiquetas al objeto Seurat
Idents(so) <- so$Proplabels

table(Idents(so))

# Eliminamos los tipos celulares con menos de 350 OJO solo para este ejemplo

`%!in%` <- Negate(`%in%`)

so <- subset(so, (Proplabels %!in% c("Pro-Myelocyte", "MEP", "Pro-B_cell_CD34+", "Pro-B_cell_CD34+", "HSC_-G-CSF", "Hepatocytes", "MSC","Osteoblasts","HSC_CD34+","Erythroblast", "Pre-B_cell_CD34-","GMP","Neutrophils","CMP","DC")))

table(Idents(so))

# Observamos nuestros clusters

DimPlot(so, reduction = "tsne")

```

## Ahora se ven asi nuestro clusters

![](cluster_v2.png)

## ¿Y si quiero agregar un tipo celular basado en genes marcadores?

![](img/aguacate.jpg)

## Observar los marcadores {.scrollable}

Y de este modo se va dando una identidad a cada cluster.

```{r, eval=FALSE, echo=TRUE}

DimPlot(so, reduction = "umap") + theme(aspect.ratio = 1)

# Marcadores de tipos celulares
macrophague_markers <- c("APOE","APOC1", "FABP5", "FABP4")

endothelial_markers <- c("ITLN1","S100A4","MGP","FN1")

FeaturePlot(so, features = macrophague_markers, reduction = "umap",
            cols = c("#EBE6E5","#EA0C3E"), label.size = 26, pt.size = 1)


# Checar el numero de clusters 
so.renamed <- RenameIdents(dummy_neuron, `0` = "Ex", `1` = "Ex", `2` = "Pv",
                           `3` = "RORB+", `4` = "Vip", `5`= "Sst",
                           `6` = "RORB+", `7`= "RORB+", `8`= "Vip", `9`= "Ex",
                           `10`= "Non-Vip", `11`= "Ex", `12`= "Ex",
                           `13`= "CPNs", `14`= "Non-Vip", `15`= "Pv",
                           `16`= "Non-Vip", `17`= "Non-Vip", `18`= "CPNs",
                           `19` = "RORB+", `20` = "Ex", `21` = "Ex")

```



## Enfoque mixto {.scrollable}

Aqui poner el ejemplo de usar marcadores conocidos y un dataset de referencia, y al mismo tiempo eliminar clusters que no nos interesen.
