---
title: "Anotacion tipos celulares"
format: 
  revealjs:
    logo: img/cdsb.png
    footer: "EBM 2023"
editor: visual
---

## Anotación de tipos celulares

**BIENVENIDOS**

Presenta: Erick Cuevas Fernández

![](img/xolo.png){.absolute bottom="0" right="0" width="300" height="300"}

![](img/bioconductor.png){.absolute bottom="0" left="0" width="300" height="100"}

![](img/nnb.png){.absolute bottom="0" left="400" width="300" height="100"}

![](img/rmb.png){.absolute top="400" left="400" width="300" height="100"}

![](img/avatar.png){.absolute top="400" left="0" width="100" height="100"}

![](img/ccg.png){.absolute top="400" left="200" width="80" height="80"}

## Anotación de clusters {.scrollable}

::: incremental
1.  **Identificación de tipos y Subtipos Celulares.**
2.  **Entender la función celular.**
3.  **Descubrimiento de nuevos tipos celulares.**
4.  **Base para análisis posteriores.**
:::

![](img/fruit.png){.r-stretch}

::: footer
Lisa Maria Steinheuer et al., 2021
:::

## Conjunto de datos a trabajar

[Tom Alsaigh et al. 2022](https://www.nature.com/articles/s42003-022-04056-7)

La mejor estrategia para anotar, es entender el problema.

![](img/h_sabio.jpg)

## Antes de seguir, tip para aprovechar lo mejor de dos mundos SingleCellExperiment y Seurat {.scrollable}

**De Seurat a SingleCellExperiment**

```{r, eval=FALSE, echo=TRUE}
library(SingleCellExperiment)

so # Seurat Object

sce <- as.SingleCellExperiment(so, assay = "RNA")
colData(sce) <- as.data.frame(colData(sce)) |>
  mutate_if(is.character, as.factor) |>
  DataFrame(row.names = colnames(sce))
```

**De SingleCellExperiment a Seurat**

```{r, eval=FALSE, echo=TRUE}
library(SeuratObject)

sce # SingleCellExperiment object

so <- CreateSeuratObject(
  counts = counts(sce),
  meta.data = data.frame(colData(sce)),
  project = "Nombre_del_proyecto")
```


## Notas de SeuratObject y SingleCellEXperiment Object

::: {.panel-tabset}

### SingleCellExperiment

El objeto **SCE** usa la estructura de SummarizedExperiment. Los *slots* extra que tiene son: 

1. **assays**
2. **colData**
3. **rowData** 
4. **reducedDims** 

### Seurat

El objeto **Seurat** se conforma de los siguientes *slots*: 

1. **@data**
2. **@meta.data**
3. **@assays**
4. **@reductions**

:::

## Importacion de datos {.scrollable}

::: {.r-fit-text}

Pasamos de SO a SCE

```{r, eval=FALSE, echo=TRUE}
library(Seurat)
library(dplyr)
library(SingleCellExperiment)


# Recuerda descargar primero el dataset del link
so <- readRDS("alsaigh_part2.rds")

# Lo convertimos a sce

sce <- as.SingleCellExperiment(so, assay = "RNA")
colData(sce) <- as.data.frame(colData(sce)) %>%
  mutate_if(is.character, as.factor) %>%
  DataFrame(row.names = colnames(sce))

# Definimos resolucion
cluster_cols <- grep("res.[0-9]", colnames(colData(sce)), value = TRUE)
sapply(colData(sce)[cluster_cols], nlevels)


```

:::

## Enfoque automático: a partir de un dataset de referencia {.scrollable}

**Dataset de referencia**

```{r, eval=FALSE, echo=TRUE}

# Para anotar
# cargar datos de referencia con anotaciones de Ensembl.
library(celldex)
ref.data <- HumanPrimaryCellAtlasData(ensembl=TRUE)

library(biomaRt)
library(SummarizedExperiment)

# Seleccione la base de datos Ensembl
ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")

# Extraer los ID de Ensembl del objeto SummarizedExperiment
ensembl_ids <- rownames(ref.data)

# Obtener los símbolos genéticos correspondientes a los ID de Ensembl
annotations <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                     filters = "ensembl_gene_id", values = ensembl_ids, mart = ensembl)

# Fusionar anotaciones con rowData del objeto SummarizedExperiment
rowData(ref.data)$geneSymbol <- annotations$hgnc_symbol[match(ensembl_ids, annotations$ensembl_gene_id)]
rownames(ref.data) <- rowData(ref.data)$geneSymbol


```

## Usando SingleR {auto-animate="true"}

```r
library(SingleR)
library(scater)

pred <- SingleR(test = sce,
                ref = ref.data,
                labels = ref.data$label.main,
                assay.type.test=1)


```
## Usando SingleR {auto-animate="true" .scrollable}

```r
library(SingleR)
library(scater)

pred <- SingleR(test = sce, 
                ref = ref.data,
                labels = ref.data$label.main,
                assay.type.test=1,
                BPPARAM= BiocParallel::MulticoreParam(6)) # 6 CPUs.

table(pred$labels)


```
Parámetros Principales:

*    **test**: Una matriz de expresión donde las filas son genes y las columnas son células a anotar.
*    **ref**: Una lista de matrices de expresión que representan las bases de datos de referencia.
*    **labels**: Etiquetas para los tipos celulares en las bases de datos de referencia.
*    **de.method**: Método para calcular los genes diferencialmente expresados.
*    **BPPARAM**: Parámetros para la paralelización.


## Observar calidad de predicción 

::: {.panel-tabset}

### Output de la predicción

```{r}
colnames(pred)

head(sort(table(pred$labels), decreasing=TRUE))


```


### Tab B

Content for `Tab B`

:::


## Aproximación "artesanal" {.scrollable}

El dataset listo para lo que sigue lo puedes descargar desde el siguiente link: <https://drive.google.com/file/d/1HbJ0syxTcxkI1aG6dIQ6hkJ7SrLHCLfl/view?usp=drive_link>

**Primer paso cargar los datos ya pre procesados**

```{r, eval=FALSE, echo=TRUE}


#Definimos la resolucion/ numero de clusters 
# cluster_cols <- grep("res.[0-9]", colnames(colData(sce)), value = TRUE)
# sapply(colData(sce)[cluster_cols], nlevels)

so <- SetIdent(so, value = "integrated_snn_res.0.1")
so@meta.data$cluster_id <- Idents(so)

# Aqui podemos ver la cantidad de clusters por resolución
(n_cells <- table(so$cluster_id, so$sample_id))

# A partir de este paso podemos encontrar los genes mas variables de cada cluster para poder anotarlos a partir de ese método

# f.markers <- FindAllMarkers(so.renamed, min.pct = 0.25, logfc.threshold = 0.25)

# f.markers %>%
#   group_by(cluster) %>%
#   top_n(n = 10, wt = avg_log2FC) -> top10

# DoHeatmap(so, features = top10$gene) +
#   theme(text = element_text(size = 18))


```

## Observar los marcadores {.scrollable}

Y de este modo se va dando una identidad a cada cluster.

```{r, eval=FALSE, echo=TRUE}

DimPlot(so, reduction = "umap") + theme(aspect.ratio = 1)

# Marcadores de tipos celulares
macrophague_markers <- c("APOE","APOC1", "FABP5", "FABP4")

endothelial_markers <- c("ITLN1","S100A4","MGP","FN1")

FeaturePlot(so, features = macrophague_markers, reduction = "umap",
            cols = c("#EBE6E5","#EA0C3E"), label.size = 26, pt.size = 1)


# Checar el numero de clusters 
so.renamed <- RenameIdents(dummy_neuron, `0` = "Ex", `1` = "Ex", `2` = "Pv",
                           `3` = "RORB+", `4` = "Vip", `5`= "Sst",
                           `6` = "RORB+", `7`= "RORB+", `8`= "Vip", `9`= "Ex",
                           `10`= "Non-Vip", `11`= "Ex", `12`= "Ex",
                           `13`= "CPNs", `14`= "Non-Vip", `15`= "Pv",
                           `16`= "Non-Vip", `17`= "Non-Vip", `18`= "CPNs",
                           `19` = "RORB+", `20` = "Ex", `21` = "Ex")

```



## Enfoque mixto {.scrollable}

Aqui poner el ejemplo de usar marcadores conocidos y un dataset de referencia, y al mismo tiempo eliminar clusters que no nos interesen.
